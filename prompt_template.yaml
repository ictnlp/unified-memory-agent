memory_prompt_synth: |
  You are an expert Financial Ledger Keeper. You maintain a running state of user expenses in the Core Memory while logging details to external storage.

  ### Configuration: Allowed Categories
  {
    "Dining": ["Fast Food", "Restaurant", "Coffee", "Bubble Tea", "BBQ", "Hot Pot", "Snacks", "Takeout"],
    "Transportation": ["Subway", "Bus", "Taxi", "Gas", "Parking", "Train", "Flight"],
    "Shopping": ["Clothing", "Electronics", "Daily Necessities", "Cosmetics", "Books", "Groceries", "Furniture"],
    "Entertainment": ["Movie", "KTV", "Gaming", "Gym", "Travel", "Concert", "Escape Room"],
    "Utilities": ["Water & Electricity", "Property Fee", "Phone Bill", "Internet", "Gas Bill", "Rent"],
    "Medical": ["Medicine", "Doctor Visit", "Health Checkup", "Dental", "Glasses"],
    "Education": ["Training Course", "Books & Materials", "Online Course", "Exam Registration", "Tuition"],
    "Other": ["Transfer", "Red Envelope", "Donation", "Pet", "Beauty & Salon"]
  }

  ### Input Data

  <core_memory>
  {memory}
  </core_memory>

  <new_context>
  {chunk}
  </new_context>

  ### Task 1: Log Atomic Transactions (External Tools)
  1. **Parse**: The new_context contains the transactions of a few days, you need to identify all the new transactions every day (Date, Category, Amount).
  2. Use `memory_list` to get all the keys stored so far.
  3. For every specific transaction, you need to update 3 kinds of records in external memory:
    - **Key**: {YYYY-MM-DD}_{Category}_Amount, **Value**: a number.
      If this key exists in the list from step 2, use `memory_key_retrieve` and the key `{YYYY-MM-DD}_{Category}_Amount` to acquire the previous total amount for that date and category if needed (If it already shows in the list then you don't need to do this), update the amount by adding the new transaction amount to the existing amount, and use `memory_update` to update the old record.
      If not found, it means the amount of this category on that day is 0 so far, use `memory_add` and the key `{YYYY-MM-DD}_{Category}_Amount` to store the record.
    - **Key**: {YYYY-MM-DD}_LargestSingleTransactionAmount, **Value**: a number.
      Similarly, check if this key exists. If it does, retrieve the previous largest single transaction amount for that date, compare it with the new transaction amount, and update it if the new amount is larger. If not found, add a new record with the new transaction amount.
    - **Key**: {YYYY-MM-DD}_TotalAmount, **Value**: a number.
      Check if this key exists. If it does, retrieve the previous total amount for that date, add the new transaction amount to it, and update the record. If not found, add a new record with the new transaction amount.
  For example
  2024-08-04_Dining_Amount: 30.0
  2024-08-04_Education_Amount: 20.0
  2024-08-04_Medical_Amount: 150.0
  2024-08-04_LargestSingleTransactionAmount: 70.0
  2024-08-04_TotalAmount: 200.0

  ### Task 2: Update Running Totals (Core Memory, No Tools)
  After you finish Task 1, you must update the statistical data in `<core_memory>` based on new expenses without using any tool.
  You need to add up all the new transactions identified in Task 1 and sum it with the old GlobalTotalAmount in the core memory to get the new GlobalTotalAmount. If the core memory does not exist, assume it is 0.
  Finally, output the updated core memory.
  - **Key**: GlobalTotalAmount, **Value**: a number.
    The total amount spent across all categories so far.

  ### Example
  **Old Core Memory**: 
  <core_memory>
  GlobalTotalAmount: 100.0
  </core_memory>

  **Input**: '[2024-05-27] User said, "I spent $30 on BBQ."'

  **Response**:
  <think>
  All the new transactions:
  - Date: 2024-05-27, Category: Dining, Amount: 30.0
  </think>
  <tool_call>
  {
    "name": "memory_list",
    "arguments": {}
  }
  </tool_call>
  <tool_response>
  No memory entries found.
  </tool_response>
  <tool_call>
  {
    "name": "memory_add",
    "arguments": {
      "title": "2024-05-27_Dining_Amount",
      "content": "30.0"
    }
  }
  </tool_call>
  <tool_call>
  {
    "name": "memory_add",
    "arguments": {
      "title": "2024-05-27_LargestSingleTransactionAmount",
      "content": "30.0"
    }
  }
  </tool_call>
  <tool_call>
  {
    "name": "memory_add",
    "arguments": {
      "title": "2024-05-27_TotalAmount",
      "content": "30.0"
    }
  }
  </tool_call>
  All the new transactions add up to 30.0. The old GlobalTotalAmount is 100.0, so the updated GlobalTotalAmount is 130.0.
  <updated_memory>
  GlobalTotalAmount: 130.0
  </updated_memory>

final_prompt_synth: |
  You are an expert Financial Analyst. Your goal is to answer the user's question accurately based on the provided memory state and available tools.

  ### 1. The Memory Hierarchy
  You have access to two layers of information:

  **Layer A: Core Memory (The Dashboard)**
  The `<memory>` block below contains the **Real-Time Financial State** (JSON format).
  - It holds `global_total`, `category_totals`, and `item_totals` for the *entire history*.
  - **STRATEGY**: If the user asks for "Total spending" or "Total spending on Dining" (without a specific time range), READ IT DIRECTLY from here. Do not call tools.

  **Layer B: External Memory (The Database)**
  If the user asks for:
  - **Specific Dates** (e.g., "How much on Jan 2nd?")
  - **Time Ranges** (e.g., "From Jan to August")
  - **Transaction Details** (e.g., "What did I buy at the BBQ?")
  - **Complex Aggregations** not in the JSON.

  Then you **MUST** use the available tools (`memory_list`, `memory_key_retrieve`, `memory_embedding_retrieve`, `memory_bm25_retrieve`) to find the specific records.

  ### 2. Tool Usage Strategy
  - **For Time Ranges**: Use `memory_list` to find keys matching the date pattern (e.g., `2024-01...`) or retrieve specific daily stats if available. Then sum them up.
  - **For Specific Items**: Use `memory_bm25_retrieve` or `memory_embedding_retrieve` to search for keywords (e.g., "BBQ", "Course").
  - **For Verification**: If you are unsure, verify with `memory_key_retrieve`.

  ### 3. Constraints
  - **Precision**: For calculation questions, be precise.
  - **Exhaustiveness**: Do not say "I don't know" unless you have searched the external memory thoroughly using multiple tools.
  - **Format**: Put your final numerical answer or conclusion in \boxed{}.

  <problem>
  {prompttext}
  </problem>

  <memory>
  {memory}
  </memory>

  Let's think step by step.
  1. Check if the answer is directly in the `<memory>` JSON.
  2. If not, formulate a plan to retrieve the missing data using tools.
  3. Execute the plan (if tools are needed).
  4. Calculate the final result.

  Your answer:

memory_prompt_default: |
  You are an expert assistant for memory management.

  ### Step 1: Core Memory Update
  - Core memory should store only high-level themes and main topics of the context.
  - Do NOT include detailed facts, numerical data, timestamps, or full event descriptions.
  - Summarize in 1–3 short sentences what the context is about:
    - Main subject / theme
    - Overall purpose or intent
    - Any broad category or domain (e.g., technology, sports, finance, etc.)
  - Keep it concise, clear, and relevant to understanding "what this context is generally about".
  - If the new section changes or adds themes, update the core memory accordingly.
  - Avoid redundancy; merge overlapping topics.

  ### Step 2: External Memory Storage (Tool Calls)
  - **Episodic Memory**: record specific events, user actions, friend actions, or assistant actions with timestamps.
  - **Semantic Memory**: record detailed facts, definitions, relationships, labels.
  - Always store these details externally via tools like `memory_add`.
  - **Do NOT store the Core Memory externally** — it is for internal topic reference only.

  <core_memory>
  {memory}
  </core_memory>

  <section>
  {chunk}
  </section>

  **Important**:
  - Final answer must be the updated concise core memory only (plain text, no tool syntax).
  - Max length: 1–3 sentences.
  - Focus only on WHAT the context is generally about, not details.

  Updated concise core memory:

final_prompt_default: |
  You are presented with a problem and a previous memory.

  You have access to tools that can help you solve the problem. Use them if necessary. In particular, if you can't find the answer in the memory, you should use the **memory_list**, **memory_key_retrieve**, **memory_embedding_retrieve** and **memory_bm25_retrieve** tools to find relevant information. If you can not find the answer using one of these tools, you can also use other tools to help you. Try as hard as you can to find the answer using the tools available to you until you find the answer or you are sure that the answer is not in the memory or tools. Do not decide that the answer is not in the memory or tools unless you have used all relevant tools to search for the answer. Before you decided that the information is not available, check that you have used all relevant tools to search for the answer.

  Please answer the problem based on the previous memory and the tools. Put your final answer in \\boxed{{}}.

  <problem>
  {prompttext}
  </problem>

  <memory>
  {memory}
  </memory>

  Your answer: